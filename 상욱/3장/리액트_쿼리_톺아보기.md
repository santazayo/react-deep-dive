#### Summary
- useQuery의 기본 콘셉트와 사용법을 알아보자

#### Advantages
- useState는 함수형 컴포넌트에서 클로저를 이용하여 상태를 관리합니다.
    - 게으른 초기화 -> 함수를 넣어서 초기화할 수 있고 이것은 앱을 실행시 딱 한번만 실행을 한다.
- useEffect는 side effect를 관리합니다.
    - 동기적으로 부수 효과를 만드는 매커니즘이다. 그리고 이 부수 효과가 "언제" 일어나는지보다 "어떤상태값"과 함께 실행되는지 살펴보는 것이 중요하다.
    - clenup 함수를 반환하여 부수 효과를 정리할 수 있다. ex) 이벤트 리스너 제거 새로 마운트 되기 전의 상태를 가지고 있어 새로운 리스너를 추가하기전 제거 해주는 역할을 해준다. 리렌더링이 되었을 때 이전값을 청소해주는 개념이다.
    - 의존성 배열 배열을 안 넣는다면 매번 리렌더링 될 때마다 부수효과가 실행된다. 그 차이점은 useEffect안에 넣어주면 랜더링이 완료된 후에 실행이 되고, 안 넣어주면 랜더링 도중에 실행이 되어버린다.
    - useEffect안에 익명 함수를 넣지 말고 이름을 지어주어 나중에 파악하기 쉽게 하자
    - 거대한 useEffect를 만들지 마라 만약 불가피 하다면 useMemo와 useCallback을 사용하여 최적화를 하자
    - useEffect안에 사용할 콜백이면 그 안에서 코드를 작성해서 사용하자 그러면 의존성 배열도 줄일 수 있다

#### Disadvantages
- useEffect
  - eslint-disable-next-line react-hooks/exhaustive-deps를 사용하여 의존성 배열을 빈 배열로 사용할 때 경고를 무시할 수 있지만, 이것은 부수 효과가 의존성 배열에 의존하지 않는다는 것을 확신할 때만 사용해야 합니다. 버그와 가능성이 매우 크다
    - 컴포넌트의 state, props 와 같은 어떤 값의 변경과 useEffect의 부수 효과가 별개로 작동하게 되고 그럼 실제 변경 사이에 연결고리가 끊어져 있는 것이다.
  - 왜 useEffect안에서 비동기 함수를 쓰면 안 되는지 -> 극단적으로 이전 state기반 응답이 10초가 걸렸고 이후 바뀐 state 기반 응답이 1초뒤에 바로 왔다면 이전 state기반 응답이 보여지는 불상사가 생길 수 있다.

#### Example Case
- 발표 주제가 적용되어 있는 라이브러리, 실제 업무에 적용되어 있는 코드, 직접 만든 예시 코드들을 첨부하여 이해를 도와야 해요.

#### Wrap-up
- 전체적으로 느낀 점을 작성해요.
